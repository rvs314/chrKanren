#+title: Design Considerations for chrKanren

I use the terms "HOM" to mean the traditional miniKanren implementation which you might find in something like The Reasoned Schemer, "FMK" to mean faster-miniKanren and "FOMK" to mean the first-order miniKanren implementation from the mk workshop.

* Language Choice

I've been burned rather badly by using the Racket/Chez intersection, so I'll be working in pure R6RS, which should allow for best-of-both-worlds. Racket has better tooling, so I'll likely be using that, but things should work OOTB on Chez. See instructions in the README.

* Unification ⊂ CHR?

Can we implement traditional unification as CHR? I think we can, which might give us a major benefit: CHR constraints are modular, allowing users to add new unifiable structures and custom unification rules (á la CLP(Set)). If unification is not a primitive, what is? Suppose we have the following:
- Variables are just a disjoint datatype in the language
- Variable "assignment" which is a CHR constraint
- How would ~walk~ or ~occurs-check~ work?

This seems like a nice-to-have, but not something strictly necessary. I'll come back to this once a simple first-order miniKanren is implemented.

Addendum: See [[Unification vs Projection]]

* First-Order Streams

There is likely a better way to implement first-order streams than what is currently done by FOMK. See: [[file:sketch]]. A more immediate issue is that the stepping of streams themselves seems to be baked into the stream structure: streams can /only/ be used for searches. That's probably fine but is a little disquieting.

* Unification vs Projection

Currently, rather than using explicit unification/type-constraint goal, I use a single projection goal which should encompass them assuming the right constraint handling logic is in place. I'd like to replace this with CHR-specific stuff once that comes into being.

Addendum: I've given up on this goal, unfortunately. I may go back and re-implement something like this, but it seems silly to force our otherwise first-order implementation to have a singular higher-order goal.

Further Addendum: This is actually just not feasible in general. We need some level of unification in order to support CHR. See [[Unification, This Time With Feeling!]]

* Randomized Testing

I've put quite a bit of work into a randomized testing harness, which should allow us to check simple algebraic properties. It's not quite done: I'd like to (at some point) add the ability to equate states/substitutions/goals up to α-equivalence. However, doing this has eaten quite a bit of time, so I think I'm going to say what I have is enough for now. Maybe once I have the reifier in place I can do something better with this. It would probably require something like birth records.

* Unification, This Time With Feeling!

I've for a long time wanted to be able to override unification in a composable way, but currently mk doesn't let you do that. I thought the way to achieve this would be to move all the logic into CHR, but that leaves us with a chicken-and-egg problem, unfortunately.

The way I currently have the system implemented is as follows:
- There is a scheme implementation of syntactic unification in [[file:unify.ss]]
- I have a primitive "assignment" constraint called ~<-~ which binds a value to a fresh logic variable
- I have a user-level constraint called ~==~ which re-implements unification. It also currently doesn't work, as we need to be able to remove constraints to prevent infinite loops.

I think this system is dumb. I want to replace ~<-~ with a primitive "syntactic unification" constraint called ~===~, then a user-level ~==~ which has the rule ~(\=\= x x) <=> succeed~. The other question that arises is how do remove unification constraints that obviously fail? We currently repeat all that logic in the unification constraint itself, which isn't great.

The issue with either of these schemes is that we can't use semantic unification when unifying constraints. For example, let's say I have a ~free-varso~ constraint that describes lambda-calculus terms which have a particular set of free variables. Matching against that constraint requires semantic unification, which is itself not a constraint. I'm not going to deal with this right now, but it's on the TODO list.

#  LocalWords:  chrKanren CHR mk HOM FMK FOM FOMK
